/*
*
*	© Copyright 2011 by TAF Co. All rights reserved.
*
*/

#include "leaf/LFSignal_HighLow.h"
#include "leaf/LFStrategy.h"

#include <sstream>
#include <cmath>
#include <iomanip>

//======================================================================
LFSignal_HighLow::LFSignal_HighLow(const LFStrategy& strat_, LFMomentumData& d_, LFMomentumData* cor_, const std::string& type_)
	:LFSignal_Market(strat_, d_, type_),
	_cor(cor_),
	_button_entry(false),
	_enters_count(0),
	_request_qty(0)

{
	if (_on)
	{
		_box_E_on_sharp = Z::get_setting_bool(_resource_base + "box_E_on_sharp", false);
		_E_on_accel_tnt = Z::get_setting_integer(_resource_base + "E_on_accel_tnt", 0);
		_E_accel_peak = tc_range<double>(Z::get_setting(_resource_base + "E_accel_peak", "1.3:1001"));
		_E_accel_bounce = tc_range<double>(Z::get_setting(_resource_base + "E_accel_bounce", "-1001:1"));
		_E_accel_max_risk = Z::get_setting_double(_resource_base + "E_accel_max_risk", 1001);
		_E_tnt_peak = tc_range<double>(Z::get_setting(_resource_base + "E_tnt_peak", "1:1001"));
		_E_tnt_band = tc_range<double>(Z::get_setting(_resource_base + "E_tnt_band", "0:1001"));
		_E_tnt_bounce = tc_range<double>(Z::get_setting(_resource_base + "E_tnt_bounce", "0.33:1"));
		_E_tnt_test = tc_range<double>(Z::get_setting(_resource_base + "E_tnt_test", "-0.25:0.25"));
		_E_tnt_approach_factor = Z::get_setting_double(_resource_base + "E_tnt_approach_factor", 0.15);
		_E_tnt_min_peak = Z::get_setting_double(_resource_base + "E_tnt_min_peak", 0);
		_E_tnt_max_band = Z::get_setting_double(_resource_base + "E_tnt_max_band", 1001);
		_E_tnt_neutral_pias = Z::get_setting_double(_resource_base + "E_tnt_neutral_pias", 0);
		_E_tnt_inband_back = Z::get_setting_integer(_resource_base + "E_tnt_inband_back", 1);
		_E_tnt_no_support = Z::get_setting_bool(_resource_base + "E_tnt_no_support", false);
		_E_tnt_support = Z::get_setting_bool(_resource_base + "E_tnt_support", true);
		_E_tnt_min_scale = Z::get_setting_integer(_resource_base + "E_tnt_min_scale", 0);
		_tnt_min_scale = Z::get_setting_integer(_resource_base + "tnt_min_scale", 0);

		_E_tnt_validate = Z::get_setting_bool(_resource_base + "E_tnt_validate", true);
		_E_tnt_none_busted = Z::get_setting_bool(_resource_base + "E_tnt_none_busted", false);
		_E_tnt_success_ticks = Z::get_setting_double(_resource_base + "E_tnt_success_ticks", 20);
		_E_accel_pias_allied = Z::get_setting_bool(_resource_base + "E_accel_pias_allied", true);
		_E_accel_reenter_any = Z::get_setting_bool(_resource_base + "E_accel_reenter_any", false);
		_X_common = Z::get_setting_bool(_resource_base + "X_common", false);
		_X_approach_min_scale = Z::get_setting_integer(_resource_base + "X_approach_min_scale", 1001);
		_X_tntz_min_scale = Z::get_setting_integer(_resource_base + "X_tntz_min_scale", 1001);
		_X_approach_factor = Z::get_setting_double(_resource_base + "X_approach_factor", 0);
		_X_approach_pct = Z::get_setting_double(_resource_base + "X_approach_pct", 0);
		_X_tntz_pct = Z::get_setting_double(_resource_base + "X_tntz_pct", 0);
		_X_tntz_test = tc_range<double>(Z::get_setting(_resource_base + "X_tntz_test", "-0.5:0.15"));

		_box_E_charge_dir_roll = Z::get_setting_double(_resource_base + "box_E_charge_dir_roll", -100);
		_box_E_charge_dir_bp = Z::get_setting_double(_resource_base + "box_E_charge_dir_bp", 0);
		_box_E_charge_q_multiplier = tc_vector<double>(Z::get_setting(_resource_base + "box_E_charge_q_multiplier", "1"));
		_box_E_min_p_charge = tc_range<double>(Z::get_setting(_resource_base + "box_E_min_p_charge", "75.1:1001"));
		_box_E_repeat_p_slope = Z::get_setting_double(_resource_base + "box_E_repeat_p_slope", 2);
		_box_E_repeat_p_slope_tip = Z::get_setting_double(_resource_base + "box_E_repeat_p_slope_tip", 0);
		_box_E_repeat_p_slope_child = Z::get_setting_double(_resource_base + "box_E_repeat_p_slope_child", 0);
		_box_E_repeat_child = Z::get_setting_double(_resource_base + "box_E_repeat_child", 0.3);
		_box_E_repeat_vol = Z::get_setting_double(_resource_base + "box_E_repeat_vol", 0);

		_box_E_repeat_p_slope_peak = Z::get_setting_double(_resource_base + "box_E_repeat_p_slope_peak", 2);
		_box_E_repeat_p_slope_peak_confirm = Z::get_setting_bool(_resource_base + "box_E_repeat_p_slope_peak_confirm", false);
		_box_E_repeat_p_slope_peak_no_enter = Z::get_setting_bool(_resource_base + "box_E_repeat_p_slope_peak_no_enter", false);
		_box_E_repeat_p_slope_shadow = Z::get_setting_double(_resource_base + "box_E_repeat_p_slope_shadow", 2);
		_box_E_repeat_p_slope_stitch = Z::get_setting_double(_resource_base + "box_E_repeat_p_slope_stitch", 0);
		_box_E_report_shadow = Z::get_setting_bool(_resource_base + "box_E_report_shadow", false);
		_box_E_report_stitch = Z::get_setting_bool(_resource_base + "box_E_report_stitch", false);
		_box_E_report_slope_peak = Z::get_setting_bool(_resource_base + "box_E_report_slope_peak", false);

		_box_E_repeat_charge = Z::get_setting_double(_resource_base + "box_E_repeat_charge", 11);
		_box_E_repeat_stitch = Z::get_setting_bool(_resource_base + "box_E_repeat_stitch", false);
		_box_E_b_len_charge_micro = Z::get_setting_double(_resource_base + "box_E_b_len_charge_micro", 0);
		_box_E_charge_exp_bounce_avg = tc_vector<double>(Z::get_setting(_resource_base + "box_E_charge_exp_bounce_avg", "20"));
		_box_E_repeat_child_reverse = Z::get_setting_bool(_resource_base + "box_E_repeat_child_reverse", false);
		_box_E_report_failed_matches = Z::get_setting_bool(_resource_base + "box_E_report_failed_matches", false);
		_box_E_diff_p_charge = tc_range<double>(Z::get_setting(_resource_base + "box_E_diff_p_charge", "7:25"));
		_box_E_diff_t_charge = tc_range<double>(Z::get_setting(_resource_base + "box_E_diff_t_charge", "1:1001"));
		_box_E_diff_p_charge_micro = Z::get_setting_double(_resource_base + "box_E_diff_p_charge_micro", 33);
		_box_E_diff_t_charge_micro = tc_vector<double>(Z::get_setting(_resource_base + "box_E_diff_t_charge_micro", "100"));

		_box_E_repeat_slope_diff = tc_range<double>(Z::get_setting(_resource_base + "box_E_repeat_slope_diff", "1:0"));
		_box_E_repeat_slope_diff_t = Z::get_setting_double(_resource_base + "box_E_repeat_slope_diff_t", 1);
		_box_E_repeat_slope_diff_p = Z::get_setting_double(_resource_base + "box_E_repeat_slope_diff_p", 7);
		_box_E_repeat_slope_diff_valid = tc_range<double>(Z::get_setting(_resource_base + "box_E_repeat_slope_diff_valid", "1:0"));

		_box_X_Profit_pct = Z::get_setting_double(_resource_base + "box_X_Profit_pct", 0);
		_box_X_cut_loss_ticks = Z::get_setting_double(_resource_base + "box_X_cut_loss_ticks", 0);

		_box_X_Micro_pct = Z::get_setting_double(_resource_base + "box_X_Micro_pct", 0);
		_box_X_MicroConf_bpct = Z::get_setting_double(_resource_base + "box_X_MicroConf_bpct", 0);
		_box_X_MicroConf_pct = Z::get_setting_double(_resource_base + "box_X_MicroConf_pct", 0);

		_box_X_Micro_ticks = tc_vector<double>(Z::get_setting(_resource_base + "box_X_Micro_ticks", "0"));
		_box_X_MicroConf_ticks = Z::get_setting_double(_resource_base + "box_X_MicroConf_ticks", -1001);
		_box_X_contra_always = Z::get_setting_bool(_resource_base + "box_X_contra_always", false);
		_box_X_BounceExact = Z::get_setting_bool(_resource_base + "box_X_BounceExact", false);


		_box_report_profit = Z::get_setting_double(_resource_base + "box_report_profit", 25);

		_box_E_repeat_force = Z::get_setting_bool(_resource_base + "box_E_repeat_force", true);
		_box_E_ignore_loss = Z::get_setting_bool(_resource_base + "box_E_ignore_loss", false);
		_box_E_ignore_loss_outside = Z::get_setting_bool(_resource_base + "box_E_ignore_loss_outside", false);
		_box_E_avg_only_limit = Z::get_setting_double(_resource_base + "box_E_avg_only_limit", 1001);
		_box_E_avg_rr_factor = Z::get_setting_double(_resource_base + "box_E_avg_rr_factor", 0);
		_box_E_cover_loss_pos_limit = tc_vector<double>(Z::get_setting(_resource_base + "box_E_cover_loss_pos_limit", "30"));
		_box_E_old_average = tc_vector<bool>(Z::get_setting(_resource_base + "box_E_old_average", "true"));
		_box_E_pias_allied = Z::get_setting_bool(_resource_base + "box_E_pias_allied", true);
		_box_E_min_density = Z::get_setting_double(_resource_base + "box_E_min_density", 0);
		_box_E_pias_contra = Z::get_setting_bool(_resource_base + "box_E_pias_contra", true);
		_box_E_pias_shadow = Z::get_setting_bool(_resource_base + "box_E_pias_shadow", true);
		_box_E_pias_shadow_stitch = Z::get_setting_bool(_resource_base + "box_E_pias_shadow_stitch", false);

		_ematches_out_file = Z::get_setting_bool(_resource_base + "ematches_out_file", false);
		_trends_out_file = Z::get_setting_bool(_resource_base + "trends_out_file", false);
		_tnt_out_file = Z::get_setting_bool(_resource_base + "tnt_out_file", false);
		_xmatch_out_file = Z::get_setting_bool(_resource_base + "xmatch_out_file", false);

		_exit_trend_end_pct = Z::get_setting_double(_resource_base + "exit_trend_end_pct", 100);

		_pre_avg_ticks = Z::get_setting_double(_resource_base + "pre_avg_ticks", 3);
	}
	_eng_cut_loss = false;
	_entry.set_key(std::string("entry_") + get_name());
	_entry._cutloss_ticks = _box_X_cut_loss_ticks;
//	_entry._old_average_logic = _box_E_old_average;

}
LFSignal_HighLow::~LFSignal_HighLow()
{
}

//======================================================================
void LFSignal_HighLow::close()
{
	LFSignal_Market::close();
	close_bias_matches(0);
}
//======================================================================
const LFSide* LFSignal_HighLow::cut_loss()
{
	const LFSide* cl_side = LFSignal_Market::cut_loss();
	if (cl_side == 0)
		return 0;

	_action = _cut_loss._action;
	const LFSide* p_side = cl_side->contra_s();
	trade_exit(p_side, 100, "cut_loss");

	return cl_side;
}
//=================================================================================
bool lf_compare_match(const LFMatchPtr& s1_, const LFMatchPtr& s2_)
{
	return s1_->_t < s2_->_t;
}
//======================================================================
void LFSignal_HighLow::update_matches()
{
	LFMatchPtrList::iterator i = _bias_enter_matches.begin();
	bool history_added = false;
	while (i != _bias_enter_matches.end())
	{
		if (update_match(*(*i)))
		{
			close_bias_match(*(*i));
			_history.push_back(*i);
			history_added = true;
			i = _bias_enter_matches.erase(i);
		}
		else
			++i;
	}
	if (history_added)
		_history.sort(lf_compare_match);
}
//======================================================================
bool LFSignal_HighLow::update_match(LFMatch& match_)
{
	if (!match_._is_enter)
		return false;
	double cv = -match_.value(_d._p, _d._model._tick_size);
	double l = LF::length_from_t(_d._t - match_._s_t);
	bool m_closed = false;
	if (cv > match_._res_max_v)
	{
		match_._res_max_v = cv;
		match_._res_max_l = l;
	}
	if (cv < match_._res_min_v)
	{
		match_._res_min_v = cv;
		match_._res_min_l = l;
	}

	if (match_._m_profit_l == 0 && match_._m_profit_v > 0 && cv > match_._m_profit_v)
	{
		match_._m_profit_l = l;
	}
	if (match_._m_loss_l == 0 && match_._m_loss_v > 0 && cv < 0 && -cv > match_._m_loss_v)
	{
		match_._m_loss_l = l;
		m_closed = true;
	}

	match_._m_success = match_._m_profit_l > 0;

	return m_closed;

}
//======================================================================
void LFSignal_HighLow::trade(const LFSide* t_side_, double q_, const std::string& comment_)
{
	LFTeaser& tsr = _teaser[t_side_->value()];
	double q = q_;
	std::string comment = comment_;
	if (tsr.valid() && !tsr._processed)
	{
		q += tsr._e_v;
		comment = tsr._comment + ", " + comment_;
	}
	tsr.reset(t_side_, _d._t, _d._p, _d._eng, 5, q, _d._model._tick_size);
	tsr._comment = comment;
}
//======================================================================
bool LFSignal_HighLow::trade_exit(const LFSide* pos_side_, double pos_pct_, const std::string& comment_)
{
	if (!_trading_on)
		return false;

	LFPositionData& pd = _strat._pos->data();

	if (pos_side_->value() != pd._side)
		return false;

	bool total = false;
	if (pd._p_remain_q > 0 && pos_pct_ > 0)
	{
		double q = (long)(pd._p_remain_q*pos_pct_ / 100. + 0.5);
		if (q == 0)
			q = 1;
		if (q > pd._p_remain_q)
		{
			q = pd._p_remain_q;
		}
		total = q >= pd._p_remain_q;
		trade(pos_side_->contra_s(), -q, comment_);
		if (_entry.valid() && _entry._side == pos_side_)
		{
			_entry.set_exit(q, _d._md);
			LF::model_send(_entry, "trade_exit", _d._t, _ematches_out_file);
			_action = LF::paTrendEnd;
		}

	}
	return total;
}
//======================================================================
void LFSignal_HighLow::close_bias_matches(const LFSide* side_)
{
	LFMatchPtrList::iterator i = _bias_enter_matches.begin();
	while (i != _bias_enter_matches.end())
	{
		if (side_ == 0 || LF::same_side((*i)->_side, side_))
		{
			close_bias_match(*(*i));
			_history.push_back(*i);
			i = _bias_enter_matches.erase(i);
		}
		else
			++i;
	}

}
//======================================================================
void LFSignal_HighLow::close_bias_match(LFMatch& match_)
{
	double cv = -match_.value(_d._p, _d._model._tick_size);
	double l = LF::length_from_t(_d._t - match_._s_t);

	match_._res_end_v = cv;
	match_._res_end_l = l;
}
//======================================================================
void LFSignal_HighLow::set_sharp_micro(const LFBox& bc_, const LFBounce& b_, const std::string& action_)
{
	_enter_sharp_chargemicro = bc_;
	_enter_sharp_chargemicro._comment = action_;
	LF::model_send(_enter_sharp_charge, "CONF_" + action_, _d._t, _ematches_out_file, _d._box_key + "_enter");
	if (_sharp_charge._side == _enter_sharp_charge._side)
		_sharp_charge.set_ended();

	LFMatchPtr m;
	m.reset(new LFMatch("micro", "micro_" + get_name(), false));
	m->reset(_enter_sharp_chargemicro._side->contra_s(), _d._t, _d._p);
	m->_comment = action_;
//	m->_m_scale = (long)_d._box_trends.find_bounce_scope(_enter_sharp_chargemicro._w);

	m->_box = _enter_sharp_chargemicro;
	m->_m_v = b_._cluster_v;
	m->_m_l = b_._cluster_l;
	m->_peak_v = _enter_sharp_chargemicro.sax_p_charge();
	m->_peak_vol = bc_._w._cluster_vol;
	m->_peak_trn = bc_._w._cluster_tran;
	m->_peak_den = bc_._w._cluster_density;
	m->_peak_frq = bc_._w._cluster_frequency;
	m->_m_vol = b_._cluster_vol;
	m->_m_trn = b_._cluster_tran;
	m->_m_den = b_._cluster_density;
	m->_m_frq = b_._cluster_frequency;
	m->_m_vol_pct = b_._vol_pct;
	m->_m_b_pct = b_._v_pct;
	m->_m_ratio = b_._l_pct;

	LF::model_send(*m, "", _d._t, _ematches_out_file, "e_" + m->_m_name);
	_history.push_back(m);
}
//======================================================================
void LFSignal_HighLow::enter_sharp_micro()
{
	if (!_enter_sharp_charge.valid() || _enter_sharp_charge.equal(_enter_sharp_chargemicro))
	{
		_sharp_charge_conf.reset();
		return;
	}
	if (!_sharp_charge_conf.valid() || _sharp_charge_conf._s_t != _enter_sharp_charge._s_t)
	{
		_sharp_charge_conf.reset(_enter_sharp_charge._side,
			_enter_sharp_charge._s_t, 0, _enter_sharp_charge._s_p);
		_d.init_merge(_sharp_charge_conf, _sharp_charge_conf._side->sign());

		//_sharp_charge_conf.reset(_enter_sharp_charge._side,
		//	_enter_sharp_charge._c_t, _enter_sharp_charge._max_corr, _enter_sharp_charge._c_p);

		LF::model_send(_sharp_charge_conf, "RESET", _d._t, _d._model._out_file_boxes, _d._box_key + "_conf");
	}
	if (!_d._box.equal(_check_box) && _sharp_charge_conf._c_t < _d._latter_box._c_t)
	{
//		_sharp_charge_conf.merge(_d._latter_box, _sharp_charge_conf._side->sign());
		_d.init_merge(_sharp_charge_conf, _sharp_charge_conf._side->sign());
		LF::model_send(_sharp_charge_conf, "MERGE", _d._t, _d._model._out_file_boxes, _d._box_key + "_conf");
	}

	LFBox bc = _sharp_charge_conf;
	_d.check_merge(bc, _d._box, bc._side->sign());
	_d.update_w(bc, true);
	_d.set_scope(bc);
	_d.set_wave(bc, _enter_sharp_charge._w);
	_enter_sharp_charge._w.set_identity(bc._w);

	LFBounce b;
	_d.set_bounce(b, bc._w, bc._c_t, bc._c_p);

	if (bc._w._wave_id < 0)
	{
		LF::model_send(bc, "BC", _d._t, _d._model._out_file_boxes, _d._box_key + "_no_scope");
		LF::model_send(_sharp_charge_conf, "conf", _d._t, _d._model._out_file_boxes, _d._box_key + "_no_scope");
		LF::model_send(_d._box, "d_box", _d._t, _d._model._out_file_boxes, _d._box_key + "_no_scope");
		set_sharp_micro(bc, b, "no_scope");
	}
	else
	{
		double indx = LF::by_val(_d._model._crl_box_charge_sets, bc.sax_p_charge(), _d._model._crl_box_charge_sets_inter);

		double max_p_slope = bc._w._cluster_s;
		const LFBoxTrend& scope = _d._box_trends[_enter_sharp_charge._w._wave_id];
		const LFBox& scope_peak = scope[bc._w._peak_id];
		const LFCluster& scope_tip = scope_peak._tip;
		
		double slt = (scope_tip._cluster_v - scope_tip.value(bc._c_p, _d._model._tick_size)) / (scope_tip._cluster_l + scope_tip.length(bc._c_t));

		size_t up_scp = _enter_sharp_charge._w._wave_id + 1;
		if (up_scp == _d._box_trends.size())
			up_scp = _enter_sharp_charge._w._wave_id;
		const LFBoxTrend& up_scope = _d._box_trends[up_scp];

		const LFCluster* scope_child = 0;
		double slc = 0;
		if (bc._w._wave_id > 0)
		{
			size_t pin;
			size_t bin;
			const LFBoxTrend& child = _d._box_trends[bc._w._wave_id - 1];
			child.find_indices(bc._w, pin, bin);
			if (pin < child.size())
			{
				scope_child = &child[pin]._w;
				slc = (scope_child->_cluster_v - scope_child->value(bc._c_p, _d._model._tick_size)) / (scope_child->_cluster_l + scope_child->length(bc._c_t));
			}
		}

		if (b._v_pct > _box_E_diff_p_charge_micro)
		{
			set_sharp_micro(bc, b, "ppct");
		}
		else if (_enter_sharp_charge._side->sign()*(_d._box._d_pias) < 0 &&
			b._l_pct > LF::by_ind(_box_E_diff_t_charge_micro, indx, _d._model._crl_box_charge_sets_inter) && b._cluster_l > _box_E_b_len_charge_micro)
		{
			set_sharp_micro(bc, b, "tpct");
		}
		else if (max_p_slope > bc._p_slope*_box_E_repeat_p_slope)
		{
			set_sharp_micro(bc, b, "slb");
		}
		else if (_box_E_repeat_p_slope_tip > 0 && max_p_slope > slt*_box_E_repeat_p_slope_tip)
		{
			std::ostringstream os;
			os << std::setprecision(1) << std::fixed;
			os << "slt[" << slt << "_" << _enter_sharp_charge._max_p_slope << "]";
			LF::model_send(scope_tip, os.str(), _d._t, _d._model._out_file_boxes, _d._box_key + "_sl");
			set_sharp_micro(bc, b, os.str());
		}
		else if (_box_E_repeat_p_slope_child > 0
			&& scope_child != 0
			&& scope_child->_cluster_v >= bc._w._cluster_v*_box_E_repeat_child
			&& max_p_slope > slc*_box_E_repeat_p_slope_child)
		{
			std::ostringstream os;
			os << std::setprecision(1) << std::fixed;
			os << "slc[" << slc << "_" << _enter_sharp_charge._max_p_slope << "]";
			LF::model_send(*scope_child, os.str(), _d._t, _d._model._out_file_boxes, _d._box_key + "_sl");
			set_sharp_micro(bc, b, os.str());
		}
		else if (_box_E_repeat_vol > 0
			&& _enter_sharp_charge._w_vol > 0
			&& b._cluster_vol > (_enter_sharp_charge._w_vol + bc._w_vol)*_box_E_repeat_vol)
		{
			std::ostringstream os;
			os << std::setprecision(1) << std::fixed;
			os << "slv[" << b._cluster_vol << "_" << _enter_sharp_charge._w_vol << "+" << bc._w_vol << "]";
			set_sharp_micro(bc, b, os.str());
		}
		else if (_box_E_repeat_child_reverse
			&& scope_child != 0
			&& slc < 0)
		{
			std::ostringstream os;
			os << std::setprecision(1) << std::fixed;
			os << "slcr[" << slc << "]";
			LF::model_send(*scope_child, os.str(), _d._t, _d._model._out_file_boxes, _d._box_key + "_sl");
			set_sharp_micro(bc, b, os.str());
		}
		else if (_enter_sharp_charge._w._s_t < up_scope[up_scope.bounce_ind(_enter_sharp_charge._side)]._w._s_t)
		{
			set_sharp_micro(bc, b, "up_scope");
		}
	}
}
//======================================================================
void LFSignal_HighLow::process_request(const LFStrategyRequest& r_)
{
	switch (r_._st_action)
	{
	case LF::stSHARP:
		process_request_sharp(r_); break;
	case LF::stTNT:
	default:
		break;
	};
}
void LFSignal_HighLow::process_request_sharp(const LFStrategyRequest& r_)
{
	if (r_._st_active)
	{
		Z::report_info("%s -- Activate_sharp - Activate (side %d)", get_name().c_str(), r_._order_side);
		if (!_d._sharp_box.valid())
		{
			Z::report_error("%s -- Activate_sharp - no valid sharp box", get_name().c_str());
			return;
		}
		if (_d._sharp_box._side->value() != r_._order_side)
		{
			Z::report_error("%s -- Activate_sharp - wrong side", get_name().c_str());
			return;
		}
		if (_enter_sharp_charge.valid())
			_enter_sharp_charge.set_ended();

		_sharp_charge.reset_from(_d._sharp_box);
		_request_qty = r_._q;
		LF::model_send(_sharp_charge, "R_SET", _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
		_action = LF::paPreEnter;
	}
	else
	{
		Z::report_info("%s -- process_request_sharp - Deactivate (side %d)", get_name().c_str(), r_._order_side);
		if (!_sharp_charge.valid())
		{
			Z::report_error("%s -- Deactivate_sharp - no valid sharp charge", get_name().c_str());
			return;
		}
		if (_sharp_charge._side->value() != r_._order_side)
		{
			Z::report_error("%s -- Deactivate_sharp - wrong side", get_name().c_str());
			return;
		}
		if (_enter_sharp_charge.valid() && !_enter_sharp_charge.ended()
			&& _sharp_charge._side == _enter_sharp_charge._side
			&& _sharp_charge._s_t <= _enter_sharp_charge._c_t)
		{
			Z::report_error("%s -- Deactivate_sharp - already entered", get_name().c_str());
			return;
		}
		_sharp_charge.reset();
	}
}
void LFSignal_HighLow::enter_sharp()
{
	if (!_d._box.equal(_check_box))
	{
		if (_enter_sharp_charge.valid() && !_enter_sharp_charge.ended())
		{
			if (_enter_sharp_charge._w._wave_id < 0)
			{
				_enter_sharp_charge.set_ended();
				LF::model_send(_enter_sharp_charge, "END_no_scope", _d._t, _ematches_out_file, _d._box_key + "_enter");
			}
			else if (!_enter_sharp_charge.turned() && _enter_sharp_charge._side->zsign(_d._box_trends[_enter_sharp_charge._w._wave_id][0]._pias) > 0)
			{
				_enter_sharp_charge.set_turned();
				LF::model_send(_enter_sharp_charge, "TURNED", _d._t, _ematches_out_file, _d._box_key + "_enter");
			}
			else
			{
				size_t up_scp = _enter_sharp_charge._w._wave_id + 1;
				if (up_scp == _d._box_trends.size())
					up_scp = _enter_sharp_charge._w._wave_id;
				const LFBoxTrend& up_scope = _d._box_trends[up_scp];
				size_t bin = up_scope.bounce_ind(_enter_sharp_charge._side);
				if (bin < up_scope.size()
					&& up_scope[bin].valid()
					&& _enter_sharp_charge._w._s_t < up_scope[bin]._w._s_t)
				{
					_enter_sharp_charge.set_ended();
					LF::model_send(_enter_sharp_charge, "END_up_scope", _d._t, _ematches_out_file, _d._box_key + "_enter");
				}
			}

		}
		if (_d._sharp_box._w.cluster_valid())
			_d._sharp_box._w._strength = 1;

		bool existing = false;
		if (_sharp_charge.valid() && !_sharp_charge.ended()
			&& _sharp_charge._c_t < _d._latter_box._c_t)
		{
//			_sharp_charge.merge(_d._latter_box, _sharp_charge._side->sign());
			_d.init_merge(_sharp_charge, _sharp_charge._side->sign());
			_d.update_w(_sharp_charge, true);
			_d.set_scope(_sharp_charge);
			LF::model_send(_sharp_charge, "MERGE", _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");

			if (_sharp_charge._max_p_slope > _sharp_charge._p_slope*_box_E_repeat_p_slope)
			{
				LF::model_send(_sharp_charge, "RESET_FLAT", _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
				_sharp_charge.set_ended();
			}
			else if (_enter_sharp_charge.valid() && !_enter_sharp_charge.ended()
				&& _sharp_charge._side == _enter_sharp_charge._side
				&& _sharp_charge._s_t <= _enter_sharp_charge._c_t)
			{
				_d.set_wave(_sharp_charge, _enter_sharp_charge._w);
				existing = true;
				//if (_enter_sharp_charge._max_p_slope > _sharp_charge._max_p_slope*_box_E_repeat_p_slope_peak
				//	|| _enter_sharp_charge._max_p_slope > _sharp_charge._p_slope*_box_E_repeat_p_slope)

				//{
				//	LF::model_send(_sharp_charge, "RESET_FLAT", _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
				//	_sharp_charge.set_ended();
				//}
			}
			else
			{
				if (_sharp_charge._max_p_slope <= _d._model._crl_box_min_slope)

				{
					LF::model_send(_sharp_charge, "RESET_SLOPE", _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
					_sharp_charge.set_ended();
				}
			}

		}
// Check stitching first
		if (_box_E_repeat_stitch
			&& _enter_sharp_charge.valid() && !_enter_sharp_charge.ended()
			&& (!_sharp_charge.valid() || _sharp_charge.ended() || _enter_sharp_charge.older(_sharp_charge))
			&& _d._latter_box._side == _enter_sharp_charge._side)
		{
			double d_value = -_enter_sharp_charge._side->v(_d._latter_box._max_p, _enter_sharp_charge._max_p, _d._model._tick_size);
			double slope = (_enter_sharp_charge.sax_p_charge() + d_value) / LF::length_from_t(_d._latter_box._max_t - _enter_sharp_charge._s_t);

			if (d_value > _box_E_repeat_charge
//				&& _enter_sharp_charge._max_p_slope > _d._model._crl_box_min_slope*_box_E_repeat_p_slope_peak
				)
			{
				if (slope*_box_E_repeat_p_slope_peak > _enter_sharp_charge._max_p_slope)
				{
					LFBox sharp_charge;
					sharp_charge.reset(_enter_sharp_charge._side,
						_enter_sharp_charge._s_t, 0, _enter_sharp_charge._s_p);
					_d.init_merge(sharp_charge, sharp_charge._side->sign());
					if (_d._latter_box._max_t == sharp_charge._max_t)
					{
						std::string comment = "STITCH";
						if (_sharp_charge.valid() && !_sharp_charge.ended())
							comment += "_REPLACE";
						_sharp_charge.reset_from(sharp_charge);
						_d.update_w(_sharp_charge, true);
						_d.set_scope(_sharp_charge);
						_d.set_wave(_sharp_charge, _enter_sharp_charge._w);
						existing = true;
						LF::model_send(_sharp_charge, comment, _d._t, _ematches_out_file, _d._box_key + "_bc");

						_d._p_store->report(comment, get_name(), _sharp_charge, _box_E_report_stitch);
					}
					else
					{
						LF::model_send(sharp_charge, "no_stitch_max", _d._t, _ematches_out_file, _d._box_key + "_bc");
					}
				}
				else
				{
					std::ostringstream os;
					os << std::setprecision(1) << std::fixed
						<< "no_stitch_slope_" << slope;
					LF::model_send(_d._latter_box, os.str(), _d._t, _ematches_out_file, _d._box_key + "_bc");
				}
			}

		}

// Check sharp
		if (_d._sharp_box.valid()
			&& _d._sharp_box.sax_p_charge() > _d._model._crl_box_min_charge
			&& _d._sharp_box._max_p_slope > _d._model._crl_box_min_slope)
		{
			bool make_bc = true;
			LFCluster stitch_to;
			if (_sharp_charge.valid())
			{
				if (_sharp_charge.ended())
				{
					if (_sharp_charge._side == _d._latter_box._side && _d._latter_box._max_t <= _sharp_charge._end_t)
					{
						make_bc = false;
						LF::model_send(_sharp_charge, "ended_same", _d._t, _ematches_out_file, _d._box_key + "_bc");
					}
				}
				else if (
//					existing  && 
					_d._sharp_box._side == _sharp_charge._side && !_d._sharp_box.older(_sharp_charge))
				{
					make_bc = false;
					LF::model_send(_sharp_charge, "existing_not_ended", _d._t, _ematches_out_file, _d._box_key + "_bc");
				}
			}
			if (make_bc && _enter_sharp_charge.valid() && !_enter_sharp_charge.ended())
			{
				if (_box_E_pias_contra && _enter_sharp_charge._side != _d._sharp_box._side)
				{
					make_bc = false;
					LF::model_send(_d._sharp_box, "pias_contra", _d._t, _ematches_out_file, _d._box_key + "_bc");
				}
				if (_box_E_pias_shadow && _enter_sharp_charge._side == _d._sharp_box._side && _enter_sharp_charge._max_t < _d._sharp_box._s_t)
				{
					_d.set_wave(_d._sharp_box, _enter_sharp_charge._w);
					if (_box_E_pias_shadow_stitch)
						stitch_to = _enter_sharp_charge._w;
					if (_box_E_repeat_p_slope_shadow > 0)
					{
						double slope = (_enter_sharp_charge.sax_p_charge() + _d._sharp_box._w_dv) / LF::length_from_t(_d._sharp_box._max_t - _enter_sharp_charge._s_t);
						if (_d._sharp_box._w_dv <= _box_E_repeat_charge
							|| slope*_box_E_repeat_p_slope_shadow <= _enter_sharp_charge._max_p_slope)
						{
							make_bc = false;
							LF::model_send(_d._sharp_box, "pias_shadow", _d._t, _ematches_out_file, _d._box_key + "_bc");
							_d._p_store->report("pias_shadow", get_name(), _d._sharp_box, _box_E_report_shadow);
						}
					}
					else
					{
						// expectation based shadow
						const LFBoxTrend& scope = _d._box_trends[_enter_sharp_charge._w._wave_id];
						size_t pin = scope.peak_ind(_d._sharp_box._side);
						if (scope[pin]._max_t < _d._sharp_box._max_t || !scope[pin]._w._pattern.test(LF::pb_ACCELERATED))
						{
							make_bc = false;
							LF::model_send(_d._sharp_box, "exp_shadow", _d._t, _ematches_out_file, _d._box_key + "_bc");
							_d._p_store->report("exp_shadow", get_name(), _d._sharp_box, _box_E_report_shadow);
						}

					}
				}
			}
				
			if(make_bc)
			{
				LFBox sharp_charge;
				std::string act;
				if (!stitch_to.valid())
				{
					act = "SET";
					sharp_charge.reset_from(_d._sharp_box);
					_d.update_w(sharp_charge, true);
					_d.set_scope(sharp_charge);
				}
				else
				{
					sharp_charge.reset(stitch_to._side,
						stitch_to._cluster_t, 0, stitch_to._cluster_p);
					_d.init_merge(sharp_charge, sharp_charge._side->sign());
					if (sharp_charge._max_p_slope > _box_E_repeat_p_slope_stitch)
					{
						act = "SET_STITCH";
					}
					else
					{
						act = "SET_no_stitch";
						sharp_charge.reset_from(_d._sharp_box);
					}

					_d.update_w(sharp_charge, true);
					_d.set_scope(sharp_charge);
					_d.set_wave(sharp_charge, stitch_to);

				}

				_sharp_charge.reset_from(sharp_charge);
				LF::model_send(sharp_charge, act, _d._t, _ematches_out_file, _d._box_key + "_bc");

				if (_box_E_min_p_charge.in(_d._sharp_box.sax_p_charge()))
					_action = LF::paPreEnter;
			}

		}

	}

	if (!_sharp_charge.valid() || _sharp_charge.ended())
	{
		_action = LF::paUndefined;
		return;
	}

	LFBox bc = _sharp_charge;
	bc.merge(_d._box, _sharp_charge._side->sign(), true);
	
	_d.update_w(bc, true);
	_d.set_scope(bc);


	bool to_enter = false;
	bool first_enter = false;
	bool to_confirm = false;
	bool any_bounce = false;
	double repeate_charge = 0;
	LFBounce b;
	_d.set_bounce(b, bc._w, bc._c_t, bc._c_p);

	double t_pct_limit = _box_E_diff_t_charge.first;
	double p_pct_limit = _box_E_diff_p_charge.first;
	if (_sharp_charge._s_t <= _enter_sharp_charge._c_t
		&& _sharp_charge._side == _enter_sharp_charge._side
		&& _box_E_repeat_slope_diff_valid.in(_enter_sharp_charge._max_p_slope)
		&& _box_E_repeat_slope_diff.in(bc._max_p_slope / _enter_sharp_charge._max_p_slope)
		)
	{
		t_pct_limit = _box_E_repeat_slope_diff_t;
		p_pct_limit = _box_E_repeat_slope_diff_p;
		any_bounce = true;
	}

	if (bc._w._wave_id < 0)
	{
		LF::model_send(bc, "NO_SCOPE", _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
	}
	else if (b.good(p_pct_limit, t_pct_limit, _d._model._crl_box_bounce_min_l))
	{
		if (_sharp_charge._s_t <= _enter_sharp_charge._c_t
			&& _sharp_charge._side == _enter_sharp_charge._side)
		{
			if (bc._max_t > _enter_sharp_charge._max_t)
			{
				to_confirm = _box_E_repeat_p_slope_peak_confirm && _enter_sharp_charge._s_t <= bc._s_t && _enter_sharp_charge._max_p_slope > bc._max_p_slope*_box_E_repeat_p_slope_peak;
				repeate_charge = _sharp_charge._side->v(_enter_sharp_charge._max_p, bc._max_p, _d._model._tick_size);

				if (repeate_charge > _box_E_repeat_charge || _sharp_charge._s_t < _enter_sharp_charge._s_t)
				{
					std::string comm = "REPEAT";
					to_enter = true;
					_action = LF::paAverage;
					if (to_confirm && _box_E_repeat_p_slope_peak_no_enter)
					{
						set_sharp_micro(bc, b, "slp");
						comm = "slope_peak";
						to_enter = false;
						_action = LF::paUndefined;
						_d._p_store->report("slope_peak", get_name(), bc, _box_E_report_slope_peak);
					}

					LF::model_send(bc, comm, _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
				}
				else
				{
					if (repeate_charge > _box_E_repeat_charge - _pre_avg_ticks)
						_action = LF::paPreAverage;

					LF::model_send(bc, "NO_REPEAT", _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
				}
			}
		}
		else
		{
			std::string comm = "FIRST";
			to_enter = true;
			first_enter = true;
			LF::model_send(bc, comm, _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
			if (_box_X_contra_always)
				trade_exit(bc._side, 100, "X_SharpCharge");

			_action = LF::paEnter;
		}
	}
	else
	{
		LF::model_send(bc, "NO_DIFF", _d._t, _d._model._out_file_boxes, _d._box_key + "_merge");
	}

	if (to_enter)
	{
		if (_enter_sharp_charge.valid() && !_enter_sharp_charge.ended()
			&& bc._side == _enter_sharp_charge._side && bc._s_t <= _enter_sharp_charge._c_t)
		{
			_d.set_wave(bc, _enter_sharp_charge._w);
		}
		const LFBoxTrend& enter_scope = _d._box_trends[bc._w._wave_id];
		const LFBox& enter_roll = enter_scope[bc._w._peak_id];
		if (bc._side->zsign(enter_roll._pias) > 0)
			bc.set_turned();
			
		size_t zero_pin = _d._box_trends[0].find_ind_best(bc._w._side, bc._w._s_t);
		LFMatchPtr m;
		m.reset(new LFMatch("sharp", "sharp_" + get_name(), true));
		m->reset(bc._side->contra_s(), _d._t, _d._p);
		m->_m_scale = bc._w._wave_id;
		m->_box = bc;
		m->_m_v = b._cluster_v;
		m->_m_l = b._cluster_l;
		m->_peak_v = bc.sax_p_charge();
		m->_peak_vol = bc._w._cluster_vol;
		m->_peak_trn = bc._w._cluster_tran;
		m->_peak_den = bc._w._cluster_density;
		m->_peak_frq = bc._w._cluster_frequency;
		m->_m_vol = b._cluster_vol;
		m->_m_trn = b._cluster_tran;
		m->_m_den = b._cluster_density;
		m->_m_frq = b._cluster_frequency;
		m->_m_vol_pct = b._vol_pct;

		double indx = LF::by_val(_d._model._crl_box_charge_sets, m->_peak_v, _d._model._crl_box_charge_sets_inter);

		m->_exp_v = m->_peak_v*LF::by_ind(_box_E_charge_exp_bounce_avg, indx, _d._model._crl_box_charge_sets_inter) / 100. - m->_m_v;

		m->_m_b_pct = b._v_pct;
		m->_m_ratio = b._l_pct;
		m->_m_repeat_charge = repeate_charge;

		m->_m_loss_v = m->_m_v;
		m->_m_profit_v = _box_report_profit;
		if (!any_bounce)
		{
			m->_m_mask.set(LF::mb_CHARGE_DIFF, m->_m_b_pct > _box_E_diff_p_charge.second);
			m->_m_mask.set(LF::mb_T_DIFF, m->_m_ratio > _box_E_diff_t_charge.second);
		}

		if (_box_E_pias_allied
			&& bc._side->zsign(enter_roll._pias) <= 0)
		{
			m->_mp_mask.set(LF::mp_PIAS);
		}
		if (_box_E_min_density > 0
			&& zero_pin < _d._box_trends[0].size()
			&& _d._box_trends[0][zero_pin]._w.cluster_valid()
			&& _d._box_trends[0][zero_pin]._w._cluster_density > 0
			&& _d._box_trends[0][zero_pin]._w._cluster_density < _box_E_min_density)
		{
			m->_mp_mask.set(LF::mp_DENSITY);
		}
		m->_mp_mask.set(LF::mp_SLOPE, bc._w._cluster_s <= _d._model._crl_box_min_slope);

		_enter_sharp_charge = bc;
		_enter_sharp_charge._comment = m->_m_mask.to_alfa() + m->_mp_mask.to_alfa();
		LF::model_send(_enter_sharp_charge, "SET", _d._t, _ematches_out_file, _d._box_key + "_enter");
		_enter_sharp_chargemicro.reset();

		LF::model_send(*m, "", _d._t, _ematches_out_file, "e_" + m->_m_name);

		if (m->_m_mask.none())
		{
			double realized = 0;
			size_t seq = 0;
			if (m->_side == _entry._side)
			{
				if (_entry._open._q == 0)
					realized += _entry._realized_pnl;
				if (_enter_sharp_charge._s_t <= _entry._s_t)
					seq = _entry._seq + 1;
			}

			if (realized > 0)
				realized = 0;

			if (_box_E_ignore_loss)
				realized = 0;
			else if (_box_E_ignore_loss_outside && seq == 0)
				realized = 0;

			LFPositionData& pd = _strat._pos->data();
			_entry.reset(m->_side, _d._t, pd, realized, _d._md, seq);

			double q_limit = _strat._position_limit;
			double qty = 0;
			double expected_v = m->_exp_v;
			if (_request_qty != 0)
			{
				qty = _request_qty;
				_button_entry = true;
			}
			else
			{

				double avg_limit = _strat._position_limit;

				if (!_entry._open.good())
					avg_limit = std::min(LF::by_ind(_box_E_cover_loss_pos_limit, indx, _d._model._crl_box_charge_sets_inter),
					_strat._position_limit);

				_entry._old_average_logic = LF::by_ind(_box_E_old_average, indx, false);
				_entry.avg(expected_v, _enter_sharp_charge._w._s_p, _box_E_avg_rr_factor, avg_limit, _d._md, _box_X_Profit_pct);
				LF::model_send(_entry, "SharpCharge", _d._t, _ematches_out_file);

				if (_entry._enter.good())
				{
					m->_qty += _entry._enter._q;
					trade(m->_side->contra_s(), _entry._enter._q, "A_" + m->_m_name);
				}
				double strong_qty = LF::by_ind(_strat._strong_qty_set, indx, _d._model._crl_box_charge_sets_inter);

				qty = (long)(strong_qty + 0.5);
				if (m->_mp_mask.any())
					qty = 0;
				q_limit = std::max(_box_E_avg_only_limit, qty);
				q_limit = std::min(q_limit, _strat._position_limit);
				if (q_limit < 0)
					q_limit = 0;

			}

			_entry.enter(qty, q_limit, _d._md, expected_v, _box_X_Profit_pct);

			LF::model_send(_entry, "SharpCharge", _d._t, _ematches_out_file);
			if (_entry._enter.good())
			{
				m->_qty += _entry._enter._q;
				trade(m->_side->contra_s(), _entry._enter._q, "E_" + m->_m_name);
			}

			_bias_enter_matches.push_back(m);

			//size_t tr_scale = 0;
			//if (_enter_sharp_charge._w._wave_id > 0)
			//	tr_scale = _enter_sharp_charge._w._wave_id - 1;

//			_entry._trend_scale = _enter_sharp_charge._w._wave_id;

			//LFBoxTrend& trend = _d._box_trends[tr_scale];
			//trend._force_side = 0;
			//trend.model_send_trend("NOFORCE_sharp", _d._t, true);
		}
		else 
		{
			// failed match
			if(first_enter && m->_mp_mask.none())
				trade_exit(_enter_sharp_charge._side, 100, "X_BoxSharpCharge");
			if (_box_E_report_failed_matches)
				_history.push_back(m);
		}
		_request_qty = 0;

	}
}
void LFSignal_HighLow::exit_sharp_bounce()
{
	if (!_enter_sharp_charge.valid())
		return;


	const LFSide* p_side = _enter_sharp_charge._side->contra_s();

	if (!_sharp_charge_bounce.valid() || _sharp_charge_bounce._s_t != _enter_sharp_charge._max_t)
	{
		_sharp_charge_bounce.reset(_enter_sharp_charge._side->contra_s(),
			_enter_sharp_charge._max_t, 0, _enter_sharp_charge._max_p);
		_d.init_merge(_sharp_charge_bounce, _sharp_charge_bounce._side->sign());
		LF::model_send(_sharp_charge_bounce, "RESET", _d._t, _d._model._out_file_boxes, _d._box_key + "_bounce");
	}
	else if (_sharp_charge_bounce.ended())
	{
		return;
	}
	else if (_enter_sharp_chargemicro.equal(_enter_sharp_charge)
//			&& _enter_sharp_chargemicro.ended()
			&& (_entry._side != p_side || !_entry._open.good()))
	{
		_sharp_charge_bounce.set_ended();
		return;
	}
	else if (!_d._box.equal(_check_box)
		&& _sharp_charge_bounce._s_t < _d._latter_box._c_t)
	{
		if (_d.check_merge(_sharp_charge_bounce, _d._latter_box, _sharp_charge_bounce._side->sign()))
			LF::model_send(_sharp_charge_bounce, "SAME", _d._t, _d._model._out_file_boxes, _d._box_key + "_bounce");
		else
			LF::model_send(_sharp_charge_bounce, "MERGE", _d._t, _d._model._out_file_boxes, _d._box_key + "_bounce");
	}

	double b_pct = 0;
	double bmax_pct = 0;
	double b_t_pct = 0;
	double b_v = 0;
	double b_l = 0;

	LFBox bc_bounce = _sharp_charge_bounce;
	_d.check_merge(bc_bounce, _d._box, _sharp_charge_bounce._side->sign(), true);

	bmax_pct = bc_bounce.sax_p_charge()*100. / _enter_sharp_charge.sax_p_charge();
	b_v = _sharp_charge_bounce._side->sign()*bc_bounce._p_charge;
	b_pct = b_v*100. / _enter_sharp_charge.sax_p_charge();
	b_l = bc_bounce.length();
	b_t_pct = b_l*100. / _enter_sharp_charge.length_max();


	LFBoxTrend& scope_0 = _d._box_trends[0];

	if (_enter_sharp_chargemicro.equal(_enter_sharp_charge))
	{
		//confirmed
		if (_entry._side == p_side)
		{
			double u_ticks = _entry._unrealized_ticks;
			if (scope_0._just_ended_side == p_side)
			{
				double x_pct = _box_X_MicroConf_bpct;
				if (b_pct > x_pct)
				{
					_entry.exit_pct(_box_X_MicroConf_pct, _d._md);
					if (_entry._exit.good())
					{
						LFMatchPtr m;
						m.reset(new LFMatch("MicroConf_bpct", "MicroConf_bpct_" + get_name(), false));
						m->reset(_entry._side->contra_s(), _d._t, _d._p);
						m->_box = bc_bounce;
						m->_m_v = b_v;
						m->_m_l = b_l;
						m->_m_b_pct = b_pct;
						m->_m_ratio = b_t_pct;
						m->_peak_v = _enter_sharp_chargemicro.sax_p_charge();
						m->_qty = _entry._exit._q;
						LF::model_send(*m, "", _d._t, _ematches_out_file, "x_" + m->_m_name);
						_history.push_back(m);

						std::ostringstream os;
						os << std::setprecision(0) << std::fixed
							<< "X_bpct_" << b_pct << "(" << x_pct << ")";

						trade(_entry._side->contra_s(), -_entry._exit._q, os.str());

						LF::model_send(_entry, "X_MicroConf_bpct", _d._t, _ematches_out_file);
					}
				}
			}
			size_t b_scope = _d._box_trends.find_bounce_scope(_enter_sharp_chargemicro._w, _box_X_BounceExact);

			if (b_scope < _d._box_trends.size())
			{
				LFBoxTrend& scope_bounce = _d._box_trends[b_scope];
				size_t b_peak_ind = scope_bounce.peak_ended_ind(_enter_sharp_chargemicro._side);
				LFBox& b_scope_peak = scope_bounce[b_peak_ind];
				if (scope_bounce._just_ended_side == p_side)
				{
					trade_exit(p_side, 100, "X_bscope_" + scope_bounce._prefix + "_ended");
				}
				else if (b_scope_peak._w.value(_d._p, _d._model._tick_size) < -0.9)
				{
					trade_exit(p_side, 100, "X_bscope_" + scope_bounce._prefix + "_busted");

				}
				else if (u_ticks >= _box_X_MicroConf_ticks)
				{
					size_t h_accel = _d._box_trends.size();
					for (size_t i = b_scope + 1; i > 0; --i)
					{
						LFBoxTrend& sc = _d._box_trends[i - 1];
						size_t scb = sc.bounce_ind(_enter_sharp_chargemicro._side);
						if (sc[scb]._w._pattern.test(LF::pb_ACCELERATED))
							h_accel = i - 1;

					}
					if (h_accel < _d._box_trends.size())
					{
						//					h_accel = h_accel > 0 ? h_accel - 1 : 0;
						LFBoxTrend& scope_accel = _d._box_trends[h_accel];
						size_t scb = scope_accel.bounce_ind(_enter_sharp_chargemicro._side);
						scope_accel.model_send(scb, scope_accel._prefix, _d._t, _d._model._out_file_boxes, "_accel");

						if (scope_accel._just_ended_side == p_side)
							trade_exit(p_side, 100, "X_accel_" + scope_accel._prefix + "_ended");

					}
				}
			}
		}
	}
	else
	{
		//not confirmed
		if (scope_0._just_ended_side == p_side
			&& _entry._side == p_side)
		{
			double indx = LF::by_val(_d._model._crl_box_charge_sets, _enter_sharp_charge.sax_p_charge(), _d._model._crl_box_charge_sets_inter);
			double u_ticks = _entry._unrealized_ticks;
			double x_ticks = LF::by_ind(_box_X_Micro_ticks, indx, false);
			if (u_ticks > x_ticks)
			{
				_entry.exit_pct(_box_X_Micro_pct, _d._md);
				if (_entry._exit.good())
				{
					LFMatchPtr m;
					m.reset(new LFMatch("Micro_ticks", "Micro_ticks_" + get_name(), false));
					m->reset(_entry._side->contra_s(), _d._t, _d._p);
					m->_box = bc_bounce;
					m->_m_v = b_v;
					m->_m_l = b_l;
					m->_m_b_pct = b_pct;
					m->_m_ratio = b_t_pct;
					m->_peak_v = _enter_sharp_charge.sax_p_charge();
					m->_qty = _entry._exit._q;
					LF::model_send(*m, "", _d._t, _ematches_out_file, "x_" + m->_m_name);
					_history.push_back(m);
					std::ostringstream os;
					os << std::setprecision(0) << std::fixed
						<< "X_ticks_" << u_ticks << "(" << x_ticks << ")";

					trade(_entry._side->contra_s(), -_entry._exit._q, os.str());
					LF::model_send(_entry, "X_Micro_ticks", _d._t, _ematches_out_file);
				}
			}
		}


	}
}

//======================================================================
void LFSignal_HighLow::exit_profit_loss()
{
	_entry.exit_cutloss(_d._md);
	if (_entry._exit.good())
	{
		trade(_entry._side->contra_s(), -_entry._exit._q, "X_CutLoss");
		LF::model_send(_entry, "X_CutLoss", _d._t, _ematches_out_file);
	}
	_entry.exit_takeprofit(_d._md);
	if (_entry._exit.good())
	{
		trade(_entry._side->contra_s(), -_entry._exit._q, "X_TakeProfit");
		LF::model_send(_entry, "X_TakeProfit", _d._t, _ematches_out_file);
	}
}
//======================================================================
void LFSignal_HighLow::process_sharp()
{
	if (_box_E_on_sharp)
	{
		enter_sharp();
		enter_sharp_micro();
		exit_sharp_bounce();
	}
	report_box(_d._bias_bx, _d._sharp_box, "sharp");
	if (_enter_sharp_charge.equal(_sharp_charge) && _sharp_charge._max_t <= _enter_sharp_charge._max_t)
	{
		LFBox tmp = _enter_sharp_charge;
		tmp._end_t = _sharp_charge._end_t;
		std::string bc_comment = _enter_sharp_charge._comment;
		if (_enter_sharp_chargemicro.equal(_enter_sharp_charge))
			bc_comment += "_" + _enter_sharp_chargemicro._comment;
		report_box(_d._bias_bp, tmp, bc_comment);
	}
	else
	{
		std::string bc_comment;
		if (_enter_sharp_chargemicro.equal(_sharp_charge) && _sharp_charge._max_t <= _enter_sharp_chargemicro._max_t)
			bc_comment += "_" + _enter_sharp_chargemicro._comment;
		report_box(_d._bias_bp, _sharp_charge, bc_comment);
	}
}
//======================================================================
void LFSignal_HighLow::report_box(LFBox& to_, const LFBox& b_, const std::string& comment_)
{
	to_ = b_;
	if (!b_.valid())
		return;
	if (!comment_.empty())
		to_._comment = comment_;
}

//======================================================================
void LFSignal_HighLow::reconcile_pos()
{
	if (!_entry.valid())
		return;
	_entry.mark_to_market(_d._md);

	std::string comment;
	LFPositionData& pd = _strat._pos->data();
	if (!pd._opening.good() && pd._p_remain_q == 0 && _button_entry)
	{
		_button_entry = false;
		_sharp_charge.set_ended();
		_enter_sharp_charge.set_ended();
		comment += "_br"; //button reset
	}
	if (pd._opening.good() || pd._closing.good())
	{
		double pd_q = pd._p_open._q - pd._closing._q;
		if (pd._side == _entry._side->value() && _entry._open._q != pd_q)
		{
			_entry._open.reset(pd._p_open._p, pd_q);
			_entry._max_q = std::max(_entry._max_q, _entry._open._q);
			comment += "_iq";
		}
	}
	else
	{
		if (pd._side != _entry._side->value())
		{
			if (_entry._open.good())
			{
				comment += "_s";
				if (_entry._side_confirmed)
					_entry._realized_pnl = pd._realized_pnl - _entry._pre_realized_pnl;
				else
				{
					_entry._pre_realized_pnl = pd._realized_pnl - _entry._realized_pnl;
					_entry._side_confirmed = true;
				}
				_entry._open.reset();
			}
		}
		else
		{
			_entry._side_confirmed = true;

			if (pd._open._q != _entry._open._q)
				comment += "_q";
			if (pd._open._p != _entry._open._p)
				comment += "_p";
			if (pd._realized_pnl != _entry._pre_realized_pnl + _entry._realized_pnl)
				comment += "_r";

			_entry._open = pd._open;
			_entry._realized_pnl = pd._realized_pnl - _entry._pre_realized_pnl;

		}
		if (!comment.empty())
		{
			_entry._max_q = std::max(_entry._max_q, _entry._open._q);
			_entry.mark_to_market(_d._md);
			LF::model_send(_entry, "R" + comment, _d._t, _ematches_out_file);
		}
	}
}
//======================================================================
void LFSignal_HighLow::check_trend(size_t scale_)
{
	LFBoxTrend& trend = _d._box_trends[scale_];
	if (!trend.trend_valid())
		return;

	if (trend._just_ended_side != 0)
	{
		trend.model_send(trend.peak_ended_ind(trend._just_ended_side), "Roll_Ended", _d._t, _trends_out_file, "_trend");
	}
}

//======================================================================
LFMatchPtr LFSignal_HighLow::check_micro_exit(const LFSide* pside_)
{
	LFMatchPtr m;
	if (pside_->zsign(_d._box._d_pias) < 0
		&& pside_->zsign(_check_box._d_pias) > 0)
	{
		m.reset(new LFMatch("M", "M_" + get_name(), false));
		m->reset(pside_->contra_s(), _d._t, _d._p);
		m->_box = _d._box;
		LFPoint mp;
		_d._box.fill_max(pside_, mp, _d._model._tick_size);
		_d._latter_box.fill_max(pside_, mp, _d._model._tick_size);
		m->_m_v = mp.value(m->_s_p, _d._model._tick_size);
		m->_m_l = mp.length(m->_s_t);
	}
	return m;
}
//======================================================================
void LFSignal_HighLow::approach_exit()
{
	LFPositionData& pd = _strat._pos->data();
	if (pd._side == LF::s_UNKNOWN || pd._p_remain_q <= 0)
		return;
	const LFSide* pside = LFSide::s(pd._side);

	LFBoxTrends& trends = _d._box_trends;

	LFMatchPtr m = check_micro_exit(pside);

	if (m.get() == 0)
		return;

	double mp = m->price_from_value(m->_m_v, _d._model._tick_size);
	for (size_t i = trends.size(); i > 0 && (long)i > _X_approach_min_scale; --i)
	{
		LFBoxTrend& trend = trends[i - 1];
		size_t app_bin = trend.bounce_ended_ind(pside);
		if (trend[app_bin]._w.in_approach(mp, trend[app_bin].exp_contra_p(), _X_approach_factor, _d._model._tick_size))
		{
			bool reexit = trend[app_bin]._w._te_pattern.test(LF::te_APPROACH);
			trend[app_bin]._w._te_pattern.set(LF::te_APPROACH);
			if (!reexit)
			{
				m->_m_scale = (double)(10 * (i - 1) + app_bin);
				LF::model_send(*m, "", _d._t, _ematches_out_file, "x_app_" + m->_m_name);
				trade_exit(pside, _X_approach_pct, "X_app_" + trend._prefix);
				break;
			}
		}
	}
	for (size_t i = trends.size(); i > 0 && (long)i > _X_tntz_min_scale; --i)
	{
		LFBoxTrend& trend = trends[i - 1];
		size_t app_bin = trend.find_ind_before(m->_side, m->_s_t);
		if (app_bin <= 3)
		{
		}
	}
}
//======================================================================
LFMatchPtr LFSignal_HighLow::check_exit(const LFSide* pside_)
{
	LFMatchPtr m;
	LFBoxTrends& trends = _d._box_trends;
	for (size_t i = 0; i < trends.size(); ++i)
	{
		LFBoxTrend& trend = trends[i];
		if (trend._just_crossed_pin < trend.size()
			&& trend._trend_side == pside_
			&& trend[trend._just_crossed_pin]._side == pside_->contra_s())
		{
			size_t dpin = trends[i].peak_ended_ind(pside_);
			LFBox& peak = trends[i][dpin];
			m.reset(new LFMatch("Com", "Com_" + get_name(), false));
			m->reset(pside_->contra_s(), _d._t, _d._p);
			m->_box = peak;
			m->_m_l = (double)(i * 10 + trend._just_crossed_pin);
			m->_m_v = peak._w.value(m->_s_p, _d._model._tick_size);
			return m;
		}
	}
	return m;
}
//======================================================================
void LFSignal_HighLow::common_exit()
{
	if (!_entry.valid())
		return;
	const LFSide* pside = _entry._side;
	const LFSide* eside = pside->contra_s();

	LFMatchPtr m = check_exit(pside);

	if (m.get() == 0)
		return;

	LFBoxTrends& trends = _d._box_trends;
	size_t rscale_min = trends.size();
	double rv_min = 0;
	for (size_t i = 0; i < trends.size(); ++i)
	{
		LFBoxTrend& trend = trends[i];
		if (trend._trend_side == pside && trend._hard_p != 0)
		{
			double v = -m->value(trend._hard_p, _d._model._tick_size);
			if (v > 0 && (rv_min == 0 || v < rv_min))
			{
				rv_min = v;
				rscale_min = i;
			}
		}
	}
	m->_qty = 100;
	if (rscale_min < trends.size())
	{
		m->_m_l += rscale_min * 1000;
		m->_m_b_pct = rv_min;
		m->_qty = rv_min*100. / (rv_min + m->_m_v);
		if (m->_qty < 0)
			m->_qty = 0;
	}
	LF::model_send(*m, "", _d._t, _ematches_out_file, "x_" + m->_m_name);
	std::ostringstream os;
	os << "X_com_" << m->_m_l << "_" << std::setprecision(1) << std::fixed << m->_qty << "%";

	_entry.exit_pct(m->_qty, _d._md);
	if (_entry._exit.good())
	{
		trade(_entry._side->contra_s(), -_entry._exit._q, os.str());
		LF::model_send(_entry, os.str(), _d._t, _ematches_out_file);
	}

}
//======================================================================
bool LFSignal_HighLow::check_turn_n_test_scale(size_t scale_, size_t x_scale_, size_t x_pin_, std::string& comment_, size_t& tnt_bin_, long& inband_, LFTnt& tnt_)
{
	LFBoxTrend& s = _d._box_trends[scale_];

	tnt_bin_ = s.size();
	tnt_.reset();
	if (!s.trend_valid())
		return false;

	comment_ += "_c" + s._prefix;

	LFBoxTrend& x_trend = _d._box_trends[x_scale_];
	if (x_pin_ == 0)
	{
		comment_ += "[xpin]";
		return false;
	}

	const LFSide* peak_side = x_trend[x_pin_]._side;
	const LFSide* b_side = peak_side->contra_s();
	tnt_bin_ = s.find_ind_before(b_side, x_trend[x_pin_]._max_t);
	if (tnt_bin_ > 3)
	{
		comment_ += "[no_b]";
		return false;
	}
	size_t x_bin = x_pin_ - 1;
	double band_p = 0;
	if (tnt_bin_ > 0)
	{
		band_p = s[tnt_bin_ - 1].exp_contra_p();
	}
	tnt_.reset(s[tnt_bin_], x_trend[x_pin_]._w, x_trend[x_bin]._w, band_p, s[tnt_bin_ + 1].exp_contra_p(), _d._model._tick_size);
	tnt_.set_factor_mask(_E_tnt_peak, _E_tnt_band, _E_tnt_bounce, _E_tnt_test);

	if (!tnt_._turn.pias_allied() && ::fabs(tnt_._turn._pias) >= _E_tnt_neutral_pias)
		tnt_._mp_mask.set(LF::mp_PIAS);
	if (tnt_._support_v > 0.)
		tnt_._mp_mask.set(LF::mp_SUPPORT, !_E_tnt_support);
	else
		tnt_._mp_mask.set(LF::mp_NO_SUPPORT, !_E_tnt_no_support);

	if (tnt_._peak_v < _E_tnt_min_peak)
		tnt_._mp_mask.set(LF::mp_P_MIN);
	if (tnt_._band_v > _E_tnt_max_band)
		tnt_._mp_mask.set(LF::mp_N_MAX);



	ACE_Time_Value till_t;
	if (tnt_bin_ + _E_tnt_inband_back < s.size())
		till_t = s[tnt_bin_ + _E_tnt_inband_back]._w._s_t;
	for (size_t d_i = 0; inband_ <= 0 && d_i < s.size() && !s[d_i]._w.older(till_t); ++d_i)
	{
		if (s[d_i]._side == b_side
			&& s[d_i].in_exp_v(_d._p, _d._model._tick_size) > 1)
		{
			inband_ = (long)(10 * scale_ + d_i);
		}
	}
	if (tnt_.in_approach(tnt_._turn.exp_contra_p(), _E_tnt_approach_factor, _d._model._tick_size))
	{
		tnt_._mp_mask.set(LF::mp_A_0);
	}
	if (s[tnt_bin_ + 1].valid())
	{
		if (tnt_.in_approach(s[tnt_bin_ + 1]._w._s_p, _E_tnt_approach_factor, _d._model._tick_size))
		{
			tnt_._mp_mask.set(LF::mp_A_1);
		}
		if (s[tnt_bin_ + 1].pias_allied() && tnt_.in_approach(s[tnt_bin_ + 1].exp_contra_p(), _E_tnt_approach_factor, _d._model._tick_size))
		{
			tnt_._mp_mask.set(LF::mp_A_1);
		}

	}
	if (s[tnt_bin_ + 3].valid())
	{
		if (tnt_.in_approach(s[tnt_bin_ + 3]._w._s_p, _E_tnt_approach_factor, _d._model._tick_size))
		{
			tnt_._mp_mask.set(LF::mp_A_2);
		}
		if (s[tnt_bin_ + 3].pias_allied() && tnt_.in_approach(s[tnt_bin_ + 3].exp_contra_p(), _E_tnt_approach_factor, _d._model._tick_size))
		{
			tnt_._mp_mask.set(LF::mp_A_2);
		}
	}
	for (size_t ii = scale_; ii > x_scale_; --ii)
	{
		LFBoxTrend& si = _d._box_trends[ii];
		size_t pi = si.peak_ended_ind(peak_side);
		if (tnt_.is_x_inside(si[pi]._w, _d._model._tick_size))
		{
			tnt_._mp_mask.set(LF::mp_P_IN);
			break;
		}
	}

	std::ostringstream os;
	os << "[";
	if (tnt_._mp_mask.any())
	{
		os << tnt_._mp_mask.to_alfa();
	}
	os << "]";
	s[tnt_bin_]._comment = "tnt" + os.str();
	comment_ += os.str();
	return tnt_._mp_mask.none();
}
//======================================================================
bool LFSignal_HighLow::validate_turn_n_test_scale(size_t scale_, size_t x_scale_, size_t x_pin_, std::string& comment_, long& inband_)
{
	if (!_E_tnt_validate)
		return true;
	LFBoxTrend& s = _d._box_trends[scale_];

	size_t tnt_bin = s.size();
	if (!s.trend_valid())
		return false;

	comment_ += "_v" + s._prefix;

	LFBoxTrend& x_trend = _d._box_trends[x_scale_];
	if (x_pin_ == 0)
	{
		comment_ += "[xp]";
		return false;
	}

	const LFSide* peak_side = x_trend[x_pin_]._side;
	const LFSide* b_side = peak_side->contra_s();
	tnt_bin = s.find_ind_before(b_side, x_trend[x_pin_]._max_t);
	if (tnt_bin > 3)
	{
		comment_ += "[no_b]";
		return false;
	}
	ACE_Time_Value till_t;
	if (tnt_bin + _E_tnt_inband_back < s.size())
		till_t = s[tnt_bin + _E_tnt_inband_back]._w._s_t;
	for (size_t d_i = 0; inband_ <= 0 && d_i < s.size() && !s[d_i]._w.older(till_t); ++d_i)
	{
		if (s[d_i]._side == b_side
			&& s[d_i].in_exp_v(_d._p, _d._model._tick_size) > 1)
		{
			inband_ = (long)(10 * scale_ + d_i);
		}
	}

	double x_p = x_trend[x_pin_]._w._s_p;
	if (s[tnt_bin]._w.in_approach(x_p, s[tnt_bin].exp_contra_p(), _E_tnt_approach_factor, _d._model._tick_size))
	{
		comment_ += "[e0_app]";
		return false;
	}
	if (tnt_bin > 0 && s[tnt_bin - 1]._w.older(x_trend[x_pin_]._w)
		&& s[tnt_bin]._w.in_approach(x_p, s[tnt_bin - 1]._w._s_p, _E_tnt_approach_factor, _d._model._tick_size))
	{
		comment_ += "[a_0p]";
		return false;
	}
	if (s[tnt_bin + 1].valid())
	{
		if (s[tnt_bin + 1].pias_allied() && s[tnt_bin]._w.in_approach(x_p, s[tnt_bin + 1]._max_p, _E_tnt_approach_factor, _d._model._tick_size))
		{
			comment_ += "[p1_app]";
			return false;
		}
		if (s[tnt_bin + 1].pias_allied() && s[tnt_bin]._w.in_approach(x_p, s[tnt_bin + 1].exp_contra_p(), _E_tnt_approach_factor, _d._model._tick_size))
		{
			comment_ += "[e1_app]";
			return false;
		}

	}
	if (s[tnt_bin + 3].valid())
	{
		if (s[tnt_bin]._w.in_approach(x_p, s[tnt_bin + 3]._max_p, _E_tnt_approach_factor, _d._model._tick_size))
		{
			comment_ += "[a_2p]";
			return false;
		}
		if (s[tnt_bin + 3].pias_allied() && s[tnt_bin]._w.in_approach(x_p, s[tnt_bin + 3].exp_contra_p(), _E_tnt_approach_factor, _d._model._tick_size))
		{
			comment_ += "[a_2e]";
			return false;
		}
	}

	comment_ += "[]";
	return true;
}
//======================================================================
size_t LFSignal_HighLow::find_turn_n_test_scale(size_t x_scale_, size_t x_pin_, std::string& comment_, size_t& tnt_bin_, long& inband_, LFTnt& tnt_)
{
	comment_ = "tnt_" + _d._box_trends[x_scale_]._prefix;
	size_t trends_size = _d._box_trends.size();
	size_t tnt = trends_size;
	bool tnt_broken = false;
	for (size_t i = x_scale_ + 1; !tnt_broken && i < trends_size; ++i)
	{
		if (tnt != trends_size)
		{
			if (!validate_turn_n_test_scale(i, x_scale_, x_pin_, comment_, inband_))
				tnt = trends_size;
		}
		else if ((long)i >= _tnt_min_scale)
		{
			if (check_turn_n_test_scale(i, x_scale_, x_pin_, comment_, tnt_bin_, inband_, tnt_))
			{
				if ((long)i >= _E_tnt_min_scale)
					tnt = i;
				if (tnt_bin_ == 0)
				{
					_d.force_set_ended(i, tnt_bin_, "tnt");
				}

				_d._box_trends.model_send(i, "T", _d._t, _tnt_out_file, "_tnt");
			}
			else
			{
				if (_E_tnt_none_busted)
				{
					tnt_broken = !tnt_._mp_mask.test(LF::mp_P_BUST)
						&& !tnt_._mp_mask.test(LF::mp_P_WEAK)
						&& (tnt_._mp_mask.test(LF::mp_B_BUST) || tnt_._mp_mask.test(LF::mp_T_BUST));
				}
				_d._box_trends.model_send(i, "f", _d._t, _tnt_out_file, "_tnt");
			}

		}
	}
	return tnt;
}
//======================================================================
bool LFSignal_HighLow::enter_accel_tnt_i(size_t scale_)
{
	LFBoxTrend& trend = _d._box_trends[scale_];
	if (!trend.trend_valid())
		return false;

	if (trend._just_crossed_pin >= trend.size())
		return false;
	const LFSide* peak_side = trend[trend._just_crossed_pin]._side;
	const LFSide* pias_side = LFSide::s_by_sign(trend[0]._pias);

	size_t pin = trend.peak_ended_ind(peak_side);
	if (pin != trend._just_crossed_pin)
		return false;

	if (trend[pin]._w._te_pattern.test(LF::te_ACCEL_CROSSED))
		return false;

	size_t bin = trend.bounce_ind(peak_side);
	if (pin < bin)
		return false;

	trend[pin]._w._te_pattern.set(LF::te_ACCEL_CROSSED);

	double bounce_eq_v = trend[pin]._w.value(trend[pin].exp_contra_p(), _d._model._tick_size);
	double bounce_v = trend[pin]._w.value(trend[bin]._max_p, _d._model._tick_size);
	double bounce_exp = bounce_eq_v > 0 ? bounce_v / bounce_eq_v : 1001;

	double peak_eq_v = trend[pin + 1]._w.value(trend[pin + 1].exp_contra_p(), _d._model._tick_size);
	double peak_v = trend[pin + 1]._w.value(trend[pin]._max_p, _d._model._tick_size);
	double peak_exp = peak_eq_v > 0 ? peak_v / peak_eq_v : 1001;


	LFMatchPtr m;
	m.reset(new LFMatch("tnt", "tnt_" + get_name(), true));
	m->reset(peak_side, _d._t, _d._p);
	m->_box = trend[pin];
	m->_m_scale = (double)scale_;
	m->_m_ratio = peak_exp;
	m->_m_b_pct = bounce_exp;
	
	m->_peak_slope = trend[pin]._w._cluster_s;
	m->_peak_tip = trend[pin].tip_s();

	m->_m_mask.set(LF::mb_ACCEL, !_E_accel_peak.in(peak_exp));
	m->_m_mask.set(LF::mb_BUSTED, !_E_accel_bounce.in(bounce_exp));
	m->_m_mask.set(LF::mb_PIAS, _E_accel_pias_allied && trend[pin]._side != pias_side);

	size_t tnt_bin = trend.size();
	long inband = 0;
	LFTnt tnt_s;
	size_t tnt_scale = find_turn_n_test_scale(scale_, pin, m->_comment, tnt_bin, inband, tnt_s);
	m->_m_mask.set(LF::mb_TNT, tnt_scale >= _d._box_trends.size());
	m->_m_mask.set(LF::mb_INBAND, inband > 0);

	m->_m_scale = (double)(tnt_scale * 100000 + 10000 * tnt_bin + 1000 * scale_ + 100 * pin + inband);
	std::ostringstream os;
	os << "xtnt_" << m->_m_scale;
	trend[pin]._comment = os.str();
	if (m->_m_mask.any() || tnt_scale >= _d._box_trends.size())
	{
		LF::model_send(*m, "", _d._t, _ematches_out_file, "e_" + m->_m_name);
		return false;
	}

	m->_peak_v = tnt_s._peak_v;
	m->_band_v = tnt_s._band_v;
	m->_band_f = tnt_s._band_f;
	m->_peak_f = tnt_s._peak_f;
	m->_bounce_f = tnt_s._bounce_f;
	m->_test_f = tnt_s._test_f;

	LFBoxTrend& tnt = _d._box_trends[tnt_scale];
	std::string mname = tnt._prefix + "_" + trend._prefix;
	//	close_bias_matches(m->_side->contra_s());
	double cur_v = tnt[tnt_bin]._w.value(_d._p, _d._model._tick_size);
	double exp_v = tnt[tnt_bin]._w.value(tnt[tnt_bin].exp_contra_p(), _d._model._tick_size);
	double tnt_v = cur_v - exp_v;
	double bust_v = -cur_v*_E_tnt_test.first;
	bust_v = std::min(bust_v, tnt_v*(_E_tnt_bounce.second - 1));

	m->_m_mask.set(LF::mb_RISK, tnt_v > _E_accel_max_risk);
	m->_m_v = tnt_v;
	m->_m_loss_v = m->_m_v + bust_v;
	m->_m_profit_v = _E_tnt_success_ticks;
	if (m->_m_profit_v <= 0)
		m->_m_profit_v = m->_m_loss_v;
	///
	bool reenter = tnt[tnt_bin]._w._te_pattern.test(LF::te_TNT);
	tnt[tnt_bin]._w._te_pattern.set(LF::te_TNT);

//	tnt.set_in_trend(m->_side);
	//tnt._force_side = 0;
	//tnt._exit_soft_end_pct = _exit_trend_end_pct;
	//tnt._exit_hard_end_pct = 100;
	//double end_v = exp_v - bust_v;

	//tnt._hard_p = tnt[tnt_bin]._w.price_from_value(end_v, _d._model._tick_size);
	//tnt._hard_p_limit = trend[pin]._w._s_p;

	tnt.model_send_trend("SET_tnt", _d._t, _trends_out_file);

	size_t seq = 0;
	if (m->_side == _entry._side
		&& _entry._open.good()
		&& m->value(_entry._open._p, _d._model._tick_size) >= 0)
	{
		seq = _entry._seq + 1;
	}
	LFPositionData& pd = _strat._pos->data();
	_entry.reset(m->_side, _d._t, pd, 0, _d._md, 0);

	double qty = _strat._strong_qty;
	if (reenter)
	{
		qty -= _entry._open._q;
		if (qty < 0)
			qty = 0;
	}

	_entry.enter(qty, _strat._position_limit - _entry._open._q, _d._md, 0, 0);
	LF::model_send(_entry, mname, _d._t, _ematches_out_file);
	if (_entry._enter.good())
	{
		m->_qty += _entry._enter._q;
		std::ostringstream os;
		os << "E_" << m->_m_name << "_" << mname;
		trade(m->_side->contra_s(), _entry._enter._q, os.str());
	}

	LF::model_send(*m, "", _d._t, _ematches_out_file, "e_" + m->_m_name);
	_bias_enter_matches.push_back(m);

	return true;

}
//======================================================================
void LFSignal_HighLow::enter_accel_tnt(size_t till_scale_)
{
	if (_d._box_trends.size() < 1)
		return;
	for (size_t i = _d._box_trends.size(); i > till_scale_; --i)
	{
		if (enter_accel_tnt_i(i - 1))
			return;
	}
}
//======================================================================
void LFSignal_HighLow::process_box()
{
	process_sharp();

	approach_exit();


	if (_E_on_accel_tnt >= 0)
	{
		enter_accel_tnt(_E_on_accel_tnt);
	}
}

bool LFSignal_HighLow::report_trend(size_t scale_)
{
	_d._trend_side = 0;
	_d._in_trend = false;
	_d._trend_soft_p = 0;
	_d._trend_hard_p = 0;

	LFBoxTrend& trend = _d._box_trends[scale_];
	if (!trend.trend_valid())
		return false;
	if (trend._exit_hard_end_pct == 0)
		return false;

	_d._trend_side = trend._trend_side;
	_d._in_trend = trend._in_trend;
	_d._trend_soft_p = trend._soft_p;
	_d._trend_hard_p = trend._hard_p;

	return true;
}

//======================================================================
void LFSignal_HighLow::trading()
{
	reconcile_pos();
	update_matches();
	exit_profit_loss();

	if (_d._box.valid() && _d._box._c_t != _check_box._c_t)
	{
		process_box();
		_check_box = _d._box;
	}

	for (size_t i = 0; i < _d._box_trends.size(); ++i)
		check_trend(i);


	report_trend(0);

	// reporting
	_history.insert(_history.end(), _d._p_store->_to_report.begin(), _d._p_store->_to_report.end());
	_d._p_store->_to_report.clear();

}
//======================================================================
